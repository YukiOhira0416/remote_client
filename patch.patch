--- a/Globals.h
+++ b/Globals.h
@@ -41,6 +41,12 @@
 #define DISPLAY_SYNC_SERVER_IP   "192.168.0.2"
 #define DISPLAY_SYNC_SERVER_PORT 8500
 
+// Mode sync (client <-> server task tray application) configuration
+#define MODE_SYNC_SERVER_IP   "192.168.0.2"
+#define MODE_SYNC_SERVER_PORT 8600
+
+
+
 
 
 // CUDA includes
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -76,6 +76,7 @@
     InputSender.cpp
     RemoteKeyboard.cpp
     DisplaySyncClient.cpp
+    ModeSyncClient.cpp
 )
 
 # ヘッダーファイル
@@ -96,6 +97,7 @@
     InputSender.h
     RemoteKeyboard.h
     DisplaySyncClient.h
+    ModeSyncClient.h
 )
 
 # 実行ファイルを作成
--- a/main_window.h
+++ b/main_window.h
@@ -10,6 +10,7 @@
 
 class QScrollArea;
 class DisplaySyncClient;
+class ModeSyncClient;
 
 class MainWindow : public QMainWindow {
     Q_OBJECT
@@ -35,9 +36,13 @@
     void applyActiveDisplayToUi(int activeIndex);
     void updateRenderAreaByWidth();
 
+    void onSpeedSaveClicked();
+    void onModeChanged(int mode);
+
 
     Ui::MainWindow ui;
     QScrollArea* m_renderScrollArea = nullptr;
+    ModeSyncClient* m_modeSyncClient = nullptr;
     DisplaySyncClient* m_displaySyncClient = nullptr;
     std::array<QString, 4> m_displayBaseLabels{};
     bool m_updatingDisplayFromServer = false;
--- a/main_window.cpp
+++ b/main_window.cpp
@@ -12,10 +12,14 @@
 #include <QTabBar>
 #include <QFont>
 #include <QSizePolicy>
+#include <QCheckBox>
+#include <QPushButton>
+#include <QSignalBlocker>
 #include "AppShutdown.h"
 #include "window.h"
 #include "Globals.h"
 #include "RemoteKeyboard.h"
+#include "ModeSyncClient.h"
 
 namespace {
     // 右側の操作パネル(Select Display / Shortcut Key)の基準幅
@@ -26,6 +30,54 @@
 
 MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) {
     ui.setupUi(this);
+
+    // --- Mode Selection (Low/Medium/High speed) UI wiring ---
+    {
+        QCheckBox* lowCheck    = ui.checkBox;
+        QCheckBox* mediumCheck = ui.checkBox_2;
+        QCheckBox* highCheck   = ui.checkBox_3;
+
+        if (lowCheck && mediumCheck && highCheck) {
+            auto connectExclusive = [this](QCheckBox* source, QCheckBox* other1, QCheckBox* other2) {
+                if (!source) {
+                    return;
+                }
+                connect(source, &QCheckBox::toggled, this,
+                        [other1, other2](bool checked) {
+                            if (!checked) {
+                                return;
+                            }
+                            if (other1) {
+                                QSignalBlocker b1(other1);
+                                other1->setChecked(false);
+                            }
+                            if (other2) {
+                                QSignalBlocker b2(other2);
+                                other2->setChecked(false);
+                            }
+                        });
+            };
+
+            connectExclusive(lowCheck,    mediumCheck, highCheck);
+            connectExclusive(mediumCheck, lowCheck,    highCheck);
+            connectExclusive(highCheck,   lowCheck,    mediumCheck);
+        }
+    }
+
+    // Create ModeSyncClient to keep speed mode in sync with the task-tray app.
+    m_modeSyncClient = new ModeSyncClient(this);
+
+    if (m_modeSyncClient) {
+        // Apply mode changes received from the server to the UI.
+        connect(m_modeSyncClient, &ModeSyncClient::modeChanged,
+                this, &MainWindow::onModeChanged);
+    }
+
+    // Hook the Save button (on Settings tab) to notify the server of changes.
+    if (ui.pushButton_3) {
+        connect(ui.pushButton_3, &QPushButton::clicked,
+                this, &MainWindow::onSpeedSaveClicked);
+    }
 
 #ifdef _WIN32
     // RemoteKeyboard から WM_APP+1 を受け取るための HWND をグローバルに保持
@@ -452,3 +504,50 @@
 {
     updateDisplayLabels(count);
 }
+
+void MainWindow::onSpeedSaveClicked()
+{
+    if (!m_modeSyncClient) {
+        return;
+    }
+
+    QCheckBox* lowCheck    = ui.checkBox;
+    QCheckBox* mediumCheck = ui.checkBox_2;
+    QCheckBox* highCheck   = ui.checkBox_3;
+
+    int mode = 0;
+    if (lowCheck && lowCheck->isChecked()) {
+        mode = 1;
+    } else if (mediumCheck && mediumCheck->isChecked()) {
+        mode = 2;
+    } else if (highCheck && highCheck->isChecked()) {
+        mode = 3;
+    }
+
+    if (mode == 0) {
+        // Nothing selected; do not send anything.
+        return;
+    }
+
+    m_modeSyncClient->setModeFromUi(mode);
+}
+
+void MainWindow::onModeChanged(int mode)
+{
+    QCheckBox* lowCheck    = ui.checkBox;
+    QCheckBox* mediumCheck = ui.checkBox_2;
+    QCheckBox* highCheck   = ui.checkBox_3;
+
+    if (!lowCheck || !mediumCheck || !highCheck) {
+        return;
+    }
+
+    QSignalBlocker b1(lowCheck);
+    QSignalBlocker b2(mediumCheck);
+    QSignalBlocker b3(highCheck);
+
+    lowCheck->setChecked(mode == 1);
+    mediumCheck->setChecked(mode == 2);
+    highCheck->setChecked(mode == 3);
+}
+
--- a/mainwindow.ui
+++ b/mainwindow.ui
@@ -283,7 +283,7 @@
        </rect>
       </property>
       <property name="title">
-       <string>Higt-speed</string>
+       <string>High-speed</string>
       </property>
       <widget class="QCheckBox" name="checkBox_3">
        <property name="geometry">
--- a/ModeSyncClient.h
+++ b/ModeSyncClient.h
@@ -0,0 +1,54 @@
+#ifndef MODE_SYNC_CLIENT_H
+#define MODE_SYNC_CLIENT_H
+
+#include <QObject>
+#include <QTcpSocket>
+#include <QAbstractSocket>
+#include <QTimer>
+#include <QByteArray>
+
+/// @brief Keeps the "Mode Selection" (Low/Medium/High speed) in sync
+/// between this client and the task-tray application on the server.
+///
+/// Protocol (line-based, UTF-8, LF-terminated):
+///   - Client -> Server:
+///       MODE <n>\n      (n is 1, 2, or 3)
+///   - Server -> Client:
+///       MODE <n>\n      (n is 1, 2, or 3)
+///
+/// Any unknown or malformed lines are ignored.
+class ModeSyncClient : public QObject
+{
+    Q_OBJECT
+public:
+    explicit ModeSyncClient(QObject* parent = nullptr);
+
+    /// @brief Returns the last known mode (1=Low, 2=Medium, 3=High).
+    int mode() const { return m_mode; }
+
+    /// @brief Called from UI when the user presses Save after changing the mode.
+    /// The value must be 1, 2, or 3. Out-of-range values are ignored.
+    void setModeFromUi(int mode);
+
+signals:
+    /// @brief Emitted when the mode is updated from the server.
+    void modeChanged(int mode);
+
+private slots:
+    void onConnected();
+    void onDisconnected();
+    void onReadyRead();
+    void onErrorOccurred(QAbstractSocket::SocketError socketError);
+    void onReconnectTimeout();
+
+private:
+    void connectToServer();
+    void processLine(const QByteArray& line);
+
+    QTcpSocket* m_socket;
+    QTimer*     m_reconnectTimer;
+    QByteArray  m_receiveBuffer;
+    int         m_mode;
+};
+
+#endif // MODE_SYNC_CLIENT_H
--- a/ModeSyncClient.cpp
+++ b/ModeSyncClient.cpp
@@ -0,0 +1,186 @@
+#include "ModeSyncClient.h"
+#include "Globals.h"     // MODE_SYNC_SERVER_IP / MODE_SYNC_SERVER_PORT
+#include "DebugLog.h"
+
+#include <QStringList>
+#include <QList>
+
+ModeSyncClient::ModeSyncClient(QObject* parent)
+    : QObject(parent)
+    , m_socket(new QTcpSocket(this))
+    , m_reconnectTimer(new QTimer(this))
+    , m_mode(1)
+{
+    // Configure reconnect timer (5 seconds interval).
+    m_reconnectTimer->setInterval(5000);
+    m_reconnectTimer->setSingleShot(false);
+
+    connect(m_socket, &QTcpSocket::connected,
+            this, &ModeSyncClient::onConnected);
+    connect(m_socket, &QTcpSocket::disconnected,
+            this, &ModeSyncClient::onDisconnected);
+    connect(m_socket, &QTcpSocket::readyRead,
+            this, &ModeSyncClient::onReadyRead);
+    connect(m_socket, &QTcpSocket::errorOccurred,
+            this, &ModeSyncClient::onErrorOccurred);
+
+    connect(m_reconnectTimer, &QTimer::timeout,
+            this, &ModeSyncClient::onReconnectTimeout);
+
+    connectToServer();
+}
+
+void ModeSyncClient::setModeFromUi(int mode)
+{
+    if (!m_socket) {
+        return;
+    }
+
+    if (mode < 1 || mode > 3) {
+        // Out-of-range; ignore.
+        return;
+    }
+
+    // Remember the last mode requested from the UI.
+    m_mode = mode;
+
+    if (m_socket->state() != QAbstractSocket::ConnectedState) {
+        // Connection is not ready yet; the server will push the latest
+        // state again after reconnect, so we do not queue writes here.
+        return;
+    }
+
+    QByteArray line("MODE ");
+    line.append(QByteArray::number(mode));
+    line.append('\n');
+
+    qint64 written = m_socket->write(line);
+    if (written != line.size()) {
+        DebugLog(L"ModeSyncClient: failed to write full MODE command.");
+    }
+}
+
+void ModeSyncClient::connectToServer()
+{
+    if (!m_socket) {
+        return;
+    }
+
+    if (m_socket->state() == QAbstractSocket::ConnectedState ||
+        m_socket->state() == QAbstractSocket::ConnectingState) {
+        return;
+    }
+
+    // Abort any previous connection attempt and start a new one.
+    m_socket->abort();
+
+    const QString host = QString::fromLatin1(MODE_SYNC_SERVER_IP);
+    const quint16 port = static_cast<quint16>(MODE_SYNC_SERVER_PORT);
+
+    std::wstring msg = L"ModeSyncClient: connecting to server ";
+    msg += host.toStdWString();
+    msg += L":";
+    msg += std::to_wstring(port);
+    DebugLog(msg);
+
+    m_socket->connectToHost(host, port);
+}
+
+void ModeSyncClient::onConnected()
+{
+    DebugLog(L"ModeSyncClient: connected to server.");
+
+    // Stop reconnect timer while we are connected.
+    if (m_reconnectTimer->isActive()) {
+        m_reconnectTimer->stop();
+    }
+
+    // We do not send our current mode on connect; the server is the
+    // source of truth and will push the current mode via a MODE line.
+}
+
+void ModeSyncClient::onDisconnected()
+{
+    DebugLog(L"ModeSyncClient: disconnected from server.");
+
+    // Start reconnect attempts if not already running.
+    if (!m_reconnectTimer->isActive()) {
+        m_reconnectTimer->start();
+    }
+}
+
+void ModeSyncClient::onReadyRead()
+{
+    if (!m_socket) {
+        return;
+    }
+
+    m_receiveBuffer.append(m_socket->readAll());
+
+    while (true) {
+        int newlineIndex = m_receiveBuffer.indexOf('\n');
+        if (newlineIndex < 0) {
+            break; // Partial line; wait for more data.
+        }
+
+        QByteArray line = m_receiveBuffer.left(newlineIndex);
+        m_receiveBuffer.remove(0, newlineIndex + 1);
+
+        // Trim CR if present (handle CRLF).
+        if (!line.isEmpty() && line.endsWith('\r')) {
+            line.chop(1);
+        }
+
+        processLine(line);
+    }
+}
+
+void ModeSyncClient::onErrorOccurred(QAbstractSocket::SocketError socketError)
+{
+    Q_UNUSED(socketError);
+    // Log and let reconnect timer handle retries.
+    DebugLog(L"ModeSyncClient: socket error occurred.");
+
+    if (m_socket && m_socket->state() == QAbstractSocket::UnconnectedState) {
+        if (!m_reconnectTimer->isActive()) {
+            m_reconnectTimer->start();
+        }
+    }
+}
+
+void ModeSyncClient::onReconnectTimeout()
+{
+    DebugLog(L"ModeSyncClient: reconnect timer fired, trying to reconnect.");
+    connectToServer();
+}
+
+void ModeSyncClient::processLine(const QByteArray& line)
+{
+    // Split by spaces.
+    QList<QByteArray> parts = line.split(' ');
+    if (parts.isEmpty()) {
+        return;
+    }
+
+    QByteArray command = parts[0].toUpper();
+
+    if (command == "MODE" && parts.size() >= 2) {
+        bool ok = false;
+        int mode = parts[1].toInt(&ok);
+        if (!ok) {
+            return;
+        }
+
+        if (mode < 1 || mode > 3) {
+            return;
+        }
+
+        if (mode != m_mode) {
+            m_mode = mode;
+            emit modeChanged(m_mode);
+        }
+    }
+    else {
+        // Unknown command; ignore silently.
+    }
+}
